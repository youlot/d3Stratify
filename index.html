<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .link {
        fill: none;
        stroke: #555;
        a stroke-opacity: 0.4;
        stroke-width: 1px;
    }

    text {
        font-family: "Arial Black", Gadget, sans-serif;
        fill: black;
        font-weight: bold;
        font-size: 14px
    }

    .xAxis .tick text {
        fill: black;
    }

    .grid .tick line {
        stroke: grey;
        stroke-dasharray: 5, 10;
        opacity: 0.7;
    }

    .grid path {
        stroke-width: 0;
    }

    .node circle {
        fill: #999;
    }

    .node--internal circle {
        fill: #555;
    }

    .node--internal text {
        font-size: 16px;
        text-shadow: 0 2px 0 #fff, 0 -2px 0 #fff, 2px 0 0 #fff, -2px 0 0 #fff;
    }

    .node--leaf text {
        fill: #000000;
    }

    .node--collapsed text {
        fill: #000;
    }

    .node--collapsed circle {
        fill: #555;
    }

    .ballG text {
        fill: white;
    }

    .shadow {
        -webkit-filter: drop-shadow(-1.5px -1.5px 1.5px #000);
        filter: drop-shadow(-1.5px -1.5px 1.5px #000);
    }
</style>

<body>
    <svg width="2200" height="4500"></svg>
</body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

    // main svg - get the initial 2ize and append a g element to svg
    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height"),
        g = svg.append("g").attr("transform", "translate(20,20)");       // move right 20px.

    // x-scale and x-axis
    var experienceName = ["", "Basic 1.0","Alright 2.0","Handy 3.0","Expert 4.0","Guru 5.0"];
    var formatSkillPoints = function (d) {
        return experienceName[d % 6];
    }
    var xScale = d3.scaleLinear()
        .domain([0, 5]) // the values // tata 
        .range([0, (width / 3) - 60]);
    let maxWeight = 0
    var xAxis = d3.axisTop()
            .scale(xScale)
            .ticks(5)
            // .tickFormat(formatSkillPoints);
    

    // Setting up a way to handle the data
    var tree = d3.cluster()    // This D3 API method setup the Dendrogram elements position.
        .separation(function(a, b) { return a.parent == b.parent ? 3 : 4; })
        .size([height, width - (width / 3)]);    // Total width - bar chart width = Dendrogram chart width
        
        //.size([height, width - 460]);    // Total width - bar chart width = Dendrogram chart width

    //var stratify = d3.stratify()            // This D3 API method gives cvs file flat data array dimensions.
    //    .parentId(function (d) { return d.id.substring(0, d.id.lastIndexOf(".")); });

    var stratify = d3.stratify()            // This D3 API method gives cvs file flat data array dimensions.
        .id(function(d) { return d.target; })
        .parentId(function (d) { return d.source; });

    let myData;
    let root;

    d3.json("JSON2_noms_despeces_modified.json", function (error, treeData) {
        if (error) throw error;
        
        myData = addRootElements(treeData.data);
        root = stratify(myData);
        console.log(root.leaves()[0])
        maxWeight =d3.max(root.leaves(), function(d) {
            return d.data.weight;
        })
        xScale.domain([0, maxWeight])
        xAxis.scale(xScale)


        update();
    });

    function update() {

        let maxDepth = d3.max(root.leaves(), function(d) {
            return d.depth;
        });
        computeX = function(node) {
            return node.depth / (node.depth + node.height) * tree.size()[1]
        }

        // update tree size
        height = (root.leaves().length + 1) * 50;
        d3.select("svg").attr("height", height)
        tree.size([height, width - (width / 3)]);
        // tree.nodeSize([40, 200])

        // update axis
        maxWeight =d3.max(root.leaves(), function(d) {
            return d.data.weight;
        })
        xScale.domain([0, maxWeight])
        xAxis.scale(xScale)
        // generate a new hierarchy from the specified tabular data
        // root object example
        // children: Array(6) [ {…}, {…}, {…}, … ]
        // data: Object { id: "Tom", value: 0, color: undefined }
        // depth: 0
        // height: 3
        // id: "Tom"
        // parent: null
        // x: 657.7932098765434
        // y: 0
        tree(root); // d3.cluster()

        // Draw every datum a line connecting to its parent.
        var link = g.selectAll(".link")
            .data(root.descendants().slice(1))
            .enter().append("path")
            .attr("class", function(d) {
                return d.parent.isCollapsedNode? "" :"link"
            })
            .attr("d", function (d) {
                return "M" + computeX(d) + "," + d.x
                    + "C" + (computeX(d.parent) + 100) + "," + d.x
                    + " " + (computeX(d.parent) + 100) + "," + d.parent.x
                    + " " + computeX(d.parent) + "," + d.parent.x;
            });

        // Setup position for every datum; Applying different css classes to parents and leafs.
        var node = g.selectAll(".node")
            .data(root.descendants().filter(d => {
                return !d.data.isFakeLeaf;
            }))
            .enter().append("g")
            .attr("class", function (d) { return "node" + (d.children ? " node--internal" : " node--leaf") + (d.isCollapsedNode ? ' node--collapsed' : ''); })
            .attr("transform", function (d) { 
                return "translate(" + computeX(d) + "," + d.x + ")"; 
            });

        // Draw every datum a small circle.
        node.append("circle")
            .attr("r", 4);

        node.on("click", click);

        // Setup G for every leaf datum. (rectangle)
        var leafNodeG = g.selectAll(".node--leaf")
            .append("g")
            .attr("class", "node--leaf-g")
            .attr("transform", "translate(" + 8 + "," + -13 + ")"); // move rectangle to be centered to the node

        leafNodeG.append("rect")
            .attr("class", "shadow")
            .style("fill", function (d) { return "#ebebeb"; })
            .attr("width", 2)
            .attr("height", 30)
            .attr("rx", 2)
            .attr("ry", 2)
            .transition()
            .duration(800)
            // .attr("width", function (d) { 
            //     let text = Number(d.data.weight).toFixed(1) + ` - ${d.id}`;
            //     return (9 * text.length  + 20); 
            // }); 
            .attr("width", function (d) { return xScale(d.data.weight); });

        leafNodeG.append("text")
            .attr("dy", 19.5)
            .attr("x", 8)
            .style("text-anchor", "start")
            .text(function (d) {
                let text = d.id ? Number(d.data.weight).toFixed(1) + ` - ${d.id}` : '';
                return text;
            });

        // Write down text for every parent datum
        var internalNode = g.selectAll(".node--internal");
        internalNode.append("text")
            .attr("y", -10)
            .style("text-anchor", "middle")
            .text(function (d) {
                let text = Number(d.data.weight).toFixed(1) + ` - ${d.id}`;
                return text;
                //return d.id
            });

        // Attach the xAxis a the top of the document    
        g.insert("g")
                .attr("class","xAxis")
                .attr("transform", "translate(" + (7 + 2 * width / 3) + "," + 0 + ")")
                .call(xAxis);

        // tick mark for x-axis
        g.insert("g")
                .attr("class", "grid")
                .attr("transform", "translate(" + (7 + 2 * width / 3) + "," + height + ")")
                .call(d3.axisBottom()
                        .scale(xScale)
                        .ticks(5)
                        .tickSize(-height, 0, 0)
                        .tickFormat("")
                );

        // Write down text for every collapsed datum
        //var leafNodeGCollapsed = g.selectAll(".node--leaf")
        //leafNodeGCollapsed.append("text")
        //    .attr("y", -10)
        //    .style("text-anchor", "middle")
        //    .text(function (d) {
        //        return ((d.isCollapsedNode === true) ? d.data.id.substring(d.data.id.lastIndexOf(".") + 1 ) : '');
        //    });
        //var internalNodeCollapsed = g.selectAll(".node--internal");
        //internalNodeCollapsed.append("text")
        //    .attr("y", -10)
        //    .style("text-anchor", "middle")
        //    .text(function (d) {
        //        return ((d.isCollapsedNode === true) ? d.data.id.substring(d.data.id.lastIndexOf(".") + 1 ) : '');
        //    });

        // Emphasize the y-axis baseline.
        svg.selectAll(".grid").select("line")
            .style("stroke-dasharray", "20,1")
            .style("stroke", "black");

        // The moving ball
        // tata 
        //var ballG = svg.insert("g")
        //        .attr("class","ballG")
        //        .attr("stroke-width","0")
        //        .attr("transform", "translate(" + 1100 + "," + height/2 + ")");
        //ballG.insert("circle")
        //        .attr("class","shadow")
        //        .style("fill","steelblue")
        //        .attr("r", 5);
        //ballG.insert("text")
        //        .style("text-anchor", "middle")
        //        .attr("dy",5)
        //        .text("0.0");

        //// Animation functions for mouse on and off events.
        //d3.selectAll(".node--leaf-g")
        //        .on("mouseover", handleMouseOver)
        //        .on("mouseout", handleMouseOut);
        // tata 
        
        function handleMouseOver(d) {
            var leafG = d3.select(this);

            leafG.select("rect")
                    .attr("stroke","#4D4D4D")
                    .attr("stroke-width","2");


            let tmpText = Number(d.data.weight).toFixed(1) + ` - ${d.id}`;
            let textSize = (9 * tmpText.length  + 20); 
            var ballGMovement = ballG.transition()
                    .duration(400)
                    .attr("transform", "translate(" + (d.y + textSize + 90) + "," + (d.x + 1.5) + ")");

            ballGMovement.select("circle")
                    .style("fill", "#454545")
                    .attr("r", 18);

            let text = Number(d.data.weight).toFixed(1);
            ballGMovement.select("text")
                    .delay(300)
                    .text(text);
        }
        function handleMouseOut() {
            var leafG = d3.select(this);

            leafG.select("rect")
                    .attr("stroke-width","0");
        }

    }

    function collapse(d) {
        if (d.children) {
            d._children = d.children;
            d._children.forEach(collapse);
            d.children = null;
        }
    }

    function removeCurrentGraph() {
        svg.selectAll("path.link").remove();
        svg.selectAll("g.node").remove();
        svg.selectAll("g.ballG").remove();
    }


    function click(d) {
        if (d.children != null && !d.isCollapsedNode) {
            d._children = d.children;
            // d.children = null;
            console.log(d)
            d.children = [{
                children: null,
                parent: d,
                depth: d.depth +1,
                height: 1,
                id: '',
                data:{
                    isFakeLeaf: true, // flag to mark built leaves
                    weight: 0,
                    target: null,
                    source: d.id
                }
            }];
            d.isCollapsedNode = true;
        } else {
            d.children = d._children;
            d._children = null;
            d.isCollapsedNode = false;
        }

        removeCurrentGraph();
        update();
    }

    function addRootElements(data) {
        newData = [];
        elementsDone = [];
        parentsAdded = [];

        for (let elem of data) {
            if (elementsDone.indexOf(elem.target) < 0) {
                let parentExist = false;
                elementsDone.push(elem.target);

                for (let comparedElem of data) {
                    if (comparedElem.target == elem.source) {
                        parentExist = true;
                    } 
                }

                if (!parentExist) {
                    if (parentsAdded.indexOf(elem.source) < 0) {
                        newData.push({ 
                            source: 'fakeRoot',
                            target: elem.source,
                            weight: 0 
                            });
                        parentsAdded.push(elem.source);
                    }
                }
            }
        }

        newData.push({
            source: '',
            target: 'fakeRoot',
            weight: 0 
        });

        console.log(`parentsAdded : ${parentsAdded}`);
        console.log(`newData : `, newData);

        newData.push.apply(newData, data);
        return newData;
    }

    function row(d) {
        return {
            id: d.id,
            value: +d.data.weight,
            color: `#454545` 
        };
    }
</script>

